package ln

import (
	"reflect"
	"testing"

	fmp "github.com/sourcekris/goflint"
)

func TestFindGcd(t *testing.T) {
	a := fmp.NewFmpz(121891891892166)
	b := fmp.NewFmpz(15874264264299962)
	c := fmp.NewFmpz(1231231231234)
	d := new(fmp.Fmpz).Set(FindGcd(a, b))

	if c.Cmp(d) != 0 {
		t.Errorf("got %v; want %v for a = %v and b = %v", d, c, a, b)
	}
}

func TestXGCD(t *testing.T) {
	a := fmp.NewFmpz(1722)
	b := fmp.NewFmpz(897)
	g := fmp.NewFmpz(3)
	u := fmp.NewFmpz(137)
	v := fmp.NewFmpz(-263)

	gg, uu, vv := XGCD(a, b)
	if !gg.Equals(gg) || !uu.Equals(u) || !vv.Equals(v) {
		t.Errorf("got %v, %v, %v; want %v, %v and %v", gg, uu, vv, g, u, v)
	}
}

func TestNthRoot(t *testing.T) {
	a, _ := new(fmp.Fmpz).SetString("77713237568615695716302170346576685641461819634599060687131984258824396858192862333826109737083261489916798000697117881307419629077115290397370118215186293569377874182041326329956290773800630721069180572611740891681923323650082495247585531410068236651399008306243425467722604650048175895458396158243733210932878316970697747416705057982991354243485411143732741856582564118835715968059936195441872417041360726613750704659185951042587499065894415371563343612566415956707357412251427435192041578314370039687521775796785264224471922522429108336215661995333480481138394633360808437853643706456878604278193409314716908010915113045557463273544547567838042043268827673777997890389720496304638901024527666194461188851430422787567380422926075310828604017684875680088503323794946742538769935931638997923476102825078474027110316602117432695051935657303134519416398821863625450038357776744192069018252660963482605322774478855629191805668715190713013758235454222732873147245274801299052843805247853665447088224582671095362847599414790388848988353066610192348696724524023447919390115028898315805024826533598527984181872533328995114347986512911257119317984192614546717758660336645159279989500341080285132221380223848698938666746474861675766042867213066", 10)
	b, _ := new(fmp.Fmpz).SetString("4267416192075741145323847256775944681056470770576175875523746449733630385018049065430211398788992179150146250489792205316604075437767753704828856377637167368027971570788207480461606495523974020488580030931166541497929714737714134113919072534227370281842419934398897175116429310461963088706125335411534893546834080743445820284362398894543366884209637713711615982130233729676609190613992172648698536622556852225972", 10)
	c := int32(3)
	d := new(fmp.Fmpz).Root(a, c)

	if !b.Equals(d) {
		t.Errorf("got %v; want %v for a = %v and c = %v", d, b, a, c)
	}
}

func TestContfractToRational(t *testing.T) {
	expectedE, _ := new(fmp.Fmpz).SetString("8372927498234629874", 10)
	expectedN, _ := new(fmp.Fmpz).SetString("9823749823749273297", 10)
	frac := []int{0, 1, 5, 1, 3, 2, 1, 2, 2, 1, 1, 1, 154, 2, 2, 8, 1, 1, 1, 4, 3, 4, 3, 1, 1, 1, 19, 1, 1, 7, 2, 1, 3, 1, 10, 1, 14, 3, 1, 2, 2, 6, 2}
	e, n := ContfractToRational(frac)

	if !e.Equals(expectedE) || !n.Equals(expectedN) {
		t.Errorf("got %v %v; want %v %v", e, n, expectedE, expectedN)
	}
}

func TestIsPerfectSquare(t *testing.T) {
	if IsPerfectSquare(fmp.NewFmpz(64)).Sign() < 0 || IsPerfectSquare(fmp.NewFmpz(65)).Sign() > 0 {
		t.Error("IsPerfectSquare Failed")
	}
}

func TestRationalToContfract(t *testing.T) {
	e, _ := new(fmp.Fmpz).SetString("8372927498234629874", 10)
	n, _ := new(fmp.Fmpz).SetString("9823749823749273297", 10)
	frac := []int{0, 1, 5, 1, 3, 2, 1, 2, 2, 1, 1, 1, 154, 2, 2, 8, 1, 1, 1, 4, 3, 4, 3, 1, 1, 1, 19, 1, 1, 7, 2, 1, 3, 1, 10, 1, 14, 3, 1, 2, 2, 6, 2}

	testfrac := RationalToContfract(e, n)

	for i := range testfrac {
		if testfrac[i] != frac[i] {
			t.Errorf("Index %d of the result was %d wanted %d", i, testfrac[i], frac[i])
		}
	}
}

func TestSolveforD(t *testing.T) {
	p := fmp.NewFmpz(54311)
	e := fmp.NewFmpz(65537)
	q := FmpString("158304142767773473275973624083670689370769915077762416888835511454118432478825486829242855992134819928313346652550326171670356302948444602468194484069516892927291240140200374848857608566129161693687407393820501709299228594296583862100570595789385365606706350802643746830710894411204232176703046334374939501731")
	d := FmpString("3202366961024225437401042327051546624286493666159185825709910141194793831730434297613156506897776947041469725191935860984079125187288357316861055577066775317547410806245642105103224133266085961352228593400306599829530729406090559213905092312407885703344866519615905603338057992843115227254119045112779823038562373")

	testD := SolveforD(p, q, e)

	if !testD.Equals(d) {
		t.Errorf("SolveforD resolves a different d. Got %v want %v\n", testD, d)
	}
}

func TestSieveOfEratosthenes(t *testing.T) {
	primesUnder800 := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,
		199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457,
		461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739,
		743, 751, 757, 761, 769, 773, 787, 797}

	tc := SieveOfEratosthenes(800)
	if !reflect.DeepEqual(tc, primesUnder800) {
		t.Errorf("SieveOfEratosthenes() error expected %v got %v", primesUnder800, tc)
	}

}

func TestFmpString(t *testing.T) {
	tt := []struct {
		name    string
		s       string
		want    *fmp.Fmpz
		wantErr bool
	}{
		{
			name: "expected integer output",
			s:    "12345",
			want: fmp.NewFmpz(int64(12345)),
		},
		{
			name:    "unexpected string input",
			s:       "potato",
			wantErr: true,
		},
	}

	for _, tc := range tt {
		got := FmpString(tc.s)
		if tc.want != nil && !got.Equals(tc.want) && !tc.wantErr {
			t.Errorf("FmpString() failed: %s got %v wanted %v", tc.name, got, tc.want)
		}

		if tc.wantErr && tc.want == nil && !got.Equals(BigZero) {
			t.Errorf("FmpString() failed: %s wanted error but got nonzero return value: %v", tc.name, got)
		}
	}
}

func TestMLucas(t *testing.T) {
	tt := []struct {
		name string
		v    string
		a    string
		n    string
		want string
	}{
		{
			name: "small value of a",
			v:    "92913388550819122544499675569210875774374545853855938615419504477582811651175223265484814518791959772636896523531755926395582055640806385063280812113028387083695807689066705253146793516957798124034345367964950029443827122883526982870830740859083226254740560633493739486679131735490507370872567528542136460467",
			a:    "2",
			n:    "149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897",
			want: "74204215743298398162524683443195384664434232912419644216406167434262550076315210884183773337987722187748847343839511562738320169065403954486688196855661731515951857974288813059128664189824385315109633943944686725942537805699925874817156119277711929215438897766348467986875128001969208449503523222910476186916",
		},
		{
			name: "larger a",
			v:    "136260532592976240773243380383992155632818234256637222089164107655520456803359613896063532132287240321290181281788514000039491413601595396969804059030171157668949638442808033154951456691099813027903848687942033744963593710777952553233480728896660570363058698624223879870608598963212799547127434371833975824974",
			a:    "5",
			n:    "149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897",
			want: "57359968592824837415899015788154608331150944123700629932280849746509499175790076645501143387044797806656859079989622495320320537225936564458982643212693739551379527838103969787409229727763189415578310780905335074817462566418396400639202690691347489890104144635051348125001526798726280613222438734797015616408",
		},
	}

	for _, tc := range tt {
		v := FmpString(tc.v)
		a := FmpString(tc.a)
		n := FmpString(tc.n)
		wantV1 := FmpString(tc.want)
		gotV1 := MLucas(v, a, n)
		if !gotV1.Equals(wantV1) {
			t.Errorf("%s: failed: wanted %v got %v", tc.name, wantV1, gotV1)
		}
	}
}

func TestILog(t *testing.T) {
	tt := []struct {
		name string
		x    string
		b    int64
		want int64
	}{
		{
			name: "expected output for b of 2",
			x:    "12237954403211546815378395288982323792658847476975159864079409416017555658438108790372593413062659460128601746248785192337852121411303913956673952150976477",
			b:    2,
			want: 511,
		},
		{
			name: "expected output for b of 3",
			x:    "12237954403211546815378395288982323792658847476975159864079409416017555658438108790372593413062659460128601746248785192337852121411303913956673952150976477",
			b:    3,
			want: 322,
		},
	}

	for _, tc := range tt {
		x := FmpString(tc.x)
		want := fmp.NewFmpz(tc.want)

		got := ILog(x, fmp.NewFmpz(tc.b))
		if !got.Equals(want) {
			t.Errorf("ILog() failed wanted %v got %v", want, got)
		}
	}

}

func TestIsPower(t *testing.T) {
	tt := []struct {
		name string
		n    string
		want int64
	}{
		{
			name: "the only test case i have",
			n:    "149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897",
			want: 0,
		},
	}

	for _, tc := range tt {
		n := FmpString(tc.n)
		want := fmp.NewFmpz(tc.want)

		got := IsPower(n)
		if !got.Equals(want) {
			t.Errorf("IsPower() failed wanted %v got %v", want, got)
		}
	}
}

func TestFmpzMin(t *testing.T) {
	tt := []struct {
		name string
		x    int64
		y    int64
		want int64
	}{
		{
			name: "x < y",
			x:    1,
			y:    2,
			want: 1,
		},
		{
			name: "x > y",
			x:    2,
			y:    1,
			want: 1,
		},
		{
			name: "x == y",
			x:    2,
			y:    2,
			want: 2,
		},
	}

	for _, tc := range tt {
		got := FmpzMin(fmp.NewFmpz(tc.x), fmp.NewFmpz(tc.y))
		if !got.Equals(fmp.NewFmpz(tc.want)) {
			t.Errorf("FmpzMin() %s failed wanted %v got %v", tc.name, tc.want, got)
		}
	}
}

func TestSolveCRT(t *testing.T) {
	for _, tc := range []struct {
		name string
		r1   string
		m1   string
		r2   string
		m2   string
		want string
	}{
		{
			name: "large int crt",
			r1:   "112820376318708309511883266356668393396816131447182791445506209031700236878469506355658352414748854472099361508824474365112325602319862842561436679067358900089331778617100580343694334226208753320435002324108477884950933641216044198203776075918323272795752182687450526442079367110656868374931125538339145721573",
			m1:   "129114230505356333697118994510021413915051088225570531043026917550451581564734952308651566723784981323900403426111056537185011193232603296112121643742691356399992969898010827710994350803494919151948423732426591598888439712920344266205641475348312727365971717305409127667391782677854219689063549759596429716629",
			r2:   "45651293556966072304818630107703140982560165499022836594523320391474750266281527820821435052904791681898782443840766880327957385288649094238886877657228597671521358830021677304123300882210216797719566693160533018601632768048713030788957904378243453859832229603157052843135978639276611231634399594108602071349",
			m2:   "109269702205029292120022054633721536134438763741801805368759852020529400112797868566931991813909053016228871499067304592740926931055426540840268677218282537450757063806695831503892336975370479004151114020279110611956433492281834217463178735931660370487895538198474855043942908224106013915984721193047940206159",
			want: "17446992834638639179129969961058029457462398677361658450137832328330435503838651797276948890990069700515669656391607670623897280684064423087023742140145529356863469816868212911716782075239982647322703714504545802436551322108638975695013439206776300941300053940942685511792851350404139366581130688518772175108412341696958930756520037",
		},
	} {

		r1, _ := new(fmp.Fmpz).SetString(tc.r1, 10)
		m1, _ := new(fmp.Fmpz).SetString(tc.m1, 10)
		r2, _ := new(fmp.Fmpz).SetString(tc.r2, 10)
		m2, _ := new(fmp.Fmpz).SetString(tc.m2, 10)
		want, _ := new(fmp.Fmpz).SetString(tc.want, 10)

		got := SolveCRT([][]*fmp.Fmpz{[]*fmp.Fmpz{r1, m1}, []*fmp.Fmpz{r2, m2}})

		if !got.Equals(want) {
			t.Errorf("SolveCRT() %s want / got mismatch: %v / %v", tc.name, want, got)
		}
	}
}

func TestFracPow(t *testing.T) {
	for _, tc := range []struct {
		name string
		x    *fmp.Fmpz
		m    int
		n    int
		want *fmp.Fmpz
	}{
		{
			name: "x**3/16",
			x:    FmpString("207858268718455276831200912684980984824578588190204197472403531338628406400110488622194176904033713524423232229185097795372252163472504321674334445022911835680389482521223677787948987323108793945203232736942944396527891302324471875508607456094556408391316041194492812742420991377357813167227802828310432509001"),
			m:    3,
			n:    16,
			want: FmpString("6450321623639996844546908074832866850711029602947426307061"),
		},
	} {

		got := FracPow(tc.x, tc.m, tc.n)
		if !got.Equals(tc.want) {
			t.Errorf("FracPow() %s want / got mismatch: %v / %v", tc.name, tc.want, got)
		}
	}
}
